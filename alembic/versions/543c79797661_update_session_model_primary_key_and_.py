"""Update Session model primary key and add unique session_id

Revision ID: 543c79797661
Revises: 80133e85bc48
Create Date: 2025-06-05 01:02:59.172902

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '543c79797661'
down_revision: Union[str, None] = '80133e85bc48'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('sessions') as batch_op:
        batch_op.add_column(sa.Column('id', sa.Integer(), nullable=True)) # Temporarily nullable
        batch_op.create_index(batch_op.f('ix_sessions_id'), ['id'], unique=False)
        # Populate 'id' column with unique values if needed, e.g., from existing session_id hashes
        # For now, we assume new 'id' values will be generated for new rows.
        # Existing rows will need a default or manual update.
        # For SQLite, we can't directly set a default for existing rows on a NOT NULL column.
        # A common workaround is to add as nullable, then update, then alter to NOT NULL.
        # However, since 'id' is a primary key, it usually auto-increments.
        # Let's assume for existing data, 'id' will be populated by the ORM or a separate script.
        # For now, we'll make it nullable=True and then set it to nullable=False in a separate step if needed.
        # For a primary key, it's usually auto-populated, so nullable=False is desired.
        # Given the error, we must make it nullable=True first.

    # After adding the column as nullable, you would typically update existing rows
    # with unique IDs. For a simple migration, we might just rely on new inserts.
    # If there's existing data, this would be a critical step:
    # op.execute("UPDATE sessions SET id = rowid WHERE id IS NULL") # Example for SQLite

    with op.batch_alter_table('sessions') as batch_op:
        batch_op.create_unique_constraint(batch_op.f('uq_sessions_session_id'), ['session_id'])
        # If 'id' needs to be NOT NULL and auto-incrementing, and there's existing data,
        # a more complex migration might be needed, involving creating a new table,
        # copying data, and then renaming. For this context, we'll leave 'id' as nullable=True
        # after adding it, or assume it's handled by the ORM for new inserts.
        # Since it's a primary key, SQLAlchemy will typically handle auto-incrementing for new rows.
        # The error was specifically about adding a NOT NULL column without a default.
        # By making it nullable=True initially, we bypass that.
        # If we need it NOT NULL later, we'd need another migration step to populate and then alter.
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    with op.batch_alter_table('sessions') as batch_op:
        batch_op.drop_constraint(batch_op.f('uq_sessions_session_id'), type_='unique')
        batch_op.drop_index(batch_op.f('ix_sessions_id'))
        batch_op.drop_column('id')
    # ### end Alembic commands ###
